import uuid
from django.urls import  reverse
from django.shortcuts import get_object_or_404
from yookassa import Payment
from django.shortcuts import  redirect
from django.contrib import messages
import json
import logging
from django.views.decorators.http import require_GET
from django.core.serializers.json import DjangoJSONEncoder
from django.views.decorators.http import require_POST
from django.contrib.auth.decorators import login_required
from calendarapp.models import  Event
from calendarapp.forms import EventForm
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse
logger = logging.getLogger(__name__)
@csrf_exempt
def create_yookassa_payment(request, event=None):
    if request.method == 'POST':
        try:
            if event is None:
                # Создаем новое событие
                form = EventForm(request.POST)
                if not form.is_valid():
                    return JsonResponse({'error': 'Invalid form data'}, status=400)
                event = form.save(commit=False)
                event.user = request.user
                event.is_paid = False
                event.save()
            else:
                # Используем существующее событие
                event.is_paid = False
                event.save()

            return_url = request.build_absolute_uri(
                reverse('calendarapp:payment_status', args=[event.id])
            )

            payment = Payment.create({
                "amount": {
                    "value": str(event.total_cost),
                    "currency": "RUB"
                },
                "confirmation": {
                    "type": "redirect",
                    "return_url": return_url
                },
                "description": f"Бронирование стола: {event.title}",
                "metadata": {
                    "event_id": str(event.id)
                }
            }, str(uuid.uuid4()))

            return JsonResponse({
                'payment_id': payment.id,
                'confirmation_url': payment.confirmation.confirmation_url
            })

        except Exception as e:
            logger.error(f"Payment error: {str(e)}")
            return JsonResponse({'error': str(e)}, status=400)

    return JsonResponse({'error': 'Invalid request method'}, status=405)



@csrf_exempt
def check_payment_status(request, payment_id):
    if request.method == 'GET':
        payment = Payment.find_one(payment_id)
        return JsonResponse({'status': payment.status})
    return JsonResponse({'error': 'Invalid request'}, status=400)


@csrf_exempt
def payment_callback(request, booking_id):
    booking = get_object_or_404(Event, id=booking_id)

    try:
        if not booking.payment_id:
            raise ValueError("Payment ID not found")

        payment = Payment.find_one(booking.payment_id)

        if payment.status == 'succeeded':
            booking.is_paid = True
            booking.payment_status = 'succeeded'
            booking.save()
            messages.success(request, 'Бронирование успешно оплачено!')
        else:
            booking.payment_status = payment.status
            booking.save()
            messages.warning(request, f'Платеж имеет статус: {payment.status}')

    except Exception as e:
        logger.error(f"Payment callback error: {str(e)}")
        messages.error(request, 'Ошибка обработки платежа')

    return redirect('calendarapp:my_bookings')



@csrf_exempt
def pay_booking(request, booking_id):
    booking = get_object_or_404(Event, id=booking_id, user=request.user)

    if booking.is_paid:
        messages.warning(request, 'Это бронирование уже оплачено')
        return redirect('calendarapp:my_bookings')

    return_url = request.build_absolute_uri(
        reverse('calendarapp:payment_callback', args=[booking.id])
    )

    try:
        payment = Payment.create({
            "amount": {
                "value": str(booking.total_cost),
                "currency": "RUB"
            },
            "confirmation": {
                "type": "redirect",
                "return_url": return_url
            },
            "capture": True,
            "description": f"Оплата брони стола: {booking.title}",
            "metadata": {
                "booking_id": str(booking.id)
            }
        }, str(uuid.uuid4()))

        booking.payment_id = payment.id
        booking.save()

        return redirect(payment.confirmation.confirmation_url)

    except Exception as e:
        logger.error(f"Payment error: {str(e)}")
        messages.error(request, 'Ошибка при создании платежа')
        return redirect('calendarapp:my_bookings')


# calendarapp/views.py
from django.views.decorators.csrf import csrf_exempt
from django.http import HttpResponse


@csrf_exempt
def yookassa_webhook(request):
    """Обработчик webhook уведомлений от ЮKassa"""
    if request.method == 'POST':
        try:
            event_json = json.loads(request.body)
            payment_id = event_json.get('object', {}).get('id')

            if payment_id:
                # Находим соответствующее событие
                event = Event.objects.filter(payment_id=payment_id).first()
                if event:
                    payment = Payment.find_one(payment_id)
                    event.payment_status = payment.status
                    event.is_paid = (payment.status == 'succeeded')
                    event.save()

                    if payment.status == 'succeeded':
                        logger.info(f"Payment succeeded for event {event.id}")
                    else:
                        logger.info(f"Payment status changed to {payment.status} for event {event.id}")

            return HttpResponse(status=200)
        except Exception as e:
            logger.error(f"Webhook error: {str(e)}")
            return HttpResponse(status=400)

    return HttpResponse(status=405)



@login_required
@require_POST
def cancel_booking(request):
    booking_id = request.POST.get('booking_id')
    try:
        booking = Event.objects.get(id=booking_id, user=request.user)

        if booking.is_canceled:
            return JsonResponse({
                'success': False,
                'message': 'Это бронирование уже отменено'
            }, status=400)

        if booking.is_paid:
            return JsonResponse({
                'success': False,
                'message': 'Нельзя отменить оплаченное бронирование'
            }, status=400)

        booking.is_canceled = True
        booking.save()

        return JsonResponse({'success': True})

    except Event.DoesNotExist:
        return JsonResponse({
            'success': False,
            'message': 'Бронирование не найдено'
        }, status=404)



@require_GET
def booking_details_api(request, booking_id):
    try:
        booking = Event.objects.select_related('table', 'user').get(id=booking_id)

        # Проверка прав доступа
        if not request.user.is_superuser and booking.user != request.user:
            return JsonResponse({'error': 'Доступ запрещен'}, status=403)

        data = {
            'id': booking.id,
            'title': booking.title,
            'description': booking.description,
            'start_time': booking.start_time.strftime("%d.%m.%Y %H:%M"),
            'end_time': booking.end_time.strftime("%H:%M"),
            'table': {
                'number': booking.table.number,
                'table_description': booking.table.table_description,
            },
            'total_cost': booking.total_cost,
            'is_paid': booking.is_paid,
            'is_canceled': booking.is_canceled,
            'user': {
                'email': booking.user.email,
            }
        }

        return JsonResponse(data, encoder=DjangoJSONEncoder)

    except Event.DoesNotExist:
        return JsonResponse({'error': 'Бронирование не найдено'}, status=404)
